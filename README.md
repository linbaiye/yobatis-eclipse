# Yobatis
Yobatis DAO是一款以Mybatis-Generator为核心的eclipse插件；可以按照DAO层形式生成Mybatis相关代码。如果项目是基于MySQL/Mybatis/SpringMVC/Servlet(tomcat)，该插件可生成Mybatis-Generator的配置文件，减少手写配置工作量。**表结构变更以后，只需要点击鼠标就可以更新相关代码，yobatis会保留手写部分的代码(java和xml)**。

 Yobatis会根据数据库表生成相应的DAO, domain, mybatis xml文件, 以及构造查询条件的类XxxCriteria。假设有一张book表:
 
<PRE>
+--------+------------+------+-----+---------+----------------+
| Field  | Type       | Null | Key | Default | Extra          |
+--------+------------+------+-----+---------+----------------+
| id     | bigint(20) | NO   | PRI | NULL    | auto_increment |
| name   | char(100)  | YES  |     | NULL    |                |
| author | bigint(20) | YES  |     | NULL    |                |
+--------+------------+------+-----+---------+----------------+
</PRE>
```
// 根据主键查询记录
@Override
@Transactional(rollbackFor = Exception.class)
public Book getById(Long id) {
  return bookDao.selectOne(id);
}
```
```
// 查询名字为name, 或作者是authorId的所有书籍: where (name = ?) or (author_id = ?) 
@Override 
@Transactional(rollbackFor = Exception.class) 
public List nameEqualOrAuthorIs(String name, long authorId) { 
  BookCriteria criteria = BookCriteria.nameEqualTo(name).or().andAuthorEqualTo(authorId); 
  return bookDao.selectList(criteria); 
}
```
完整示例请使用该项目:https://github.com/linbaiye/yobatis-simple-example.git
# Requirements
* eclipse luna或者更高版本
* Java 8
* 仅支持MySQL
* 表必须有主键
# 安装
单击Help菜单 -> 选择Install New Software -> 单击Add，对话框中添加repository: https://linbaiye.github.io/yobatis_upsite


![alt text](https://linbaiye.github.io/yobatis/img/install1.png)

![alt text](https://linbaiye.github.io/yobatis/img/install2.png)
# 生成代码
如果项目是基于MySQL/Mybatis/SpringMVC/Servlet(tomcat)，可以尝试使用yobatis自动生成配置文件，如下图：
![usage](https://linbaiye.github.io/yobatis/img/usage.gif)


生成配置文件后，可以手动更改生成代码的存放目录。若无法自动生配置文件，则需要手写配置文件（mybatisGeneratorConfig.xml），示例如下：
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
  <!-- ${user} 为用户目录, 该选项用于加载 mysql-connector-java-5.1.25.jar，需要正确配置 -->
  <classPathEntry location="${user}/.m2/repository/mysql/mysql-connector-java/5.1.25/mysql-connector-java-5.1.25.jar"/>
  
  <context id="org.nalby.yobatis.book.model" targetRuntime="MyBatis3">
    <!-- Yobatis 插件，必须 -->
    <plugin type="org.mybatis.generator.plugins.YobatisDaoPlugin"/>
    
    <jdbcConnection driverClass="com.mysql.jdbc.Driver" 
    connectionURL="jdbc:mysql://localhost:3306/book_store?characterEncoding=utf-8" 
    userId="root" password="root"/>
    
    <javaTypeResolver>
      <property name="forceBigDecimals" value="false"/>
    </javaTypeResolver>
    
    <!-- model, criteria class文件配置 -->
    <javaModelGenerator targetPackage="org.nalby.yobatis.book.model"
    targetProject="/yobatis-simple-example/src/main/java"/>
    
    <!-- xml mapper文件配置 -->
    <sqlMapGenerator targetPackage="mybatis-mappers"
    targetProject="/yobatis-simple-example/src/main/resources"/>
    
    <!-- dao层class文件配置 -->
    <javaClientGenerator type="XMLMAPPER"
    targetPackage="org.nalby.yobatis.book.dao"
    targetProject="/yobatis-simple-example/src/main/java"/>
    
    <!-- 需要生成对应代码的表 -->
    <table tableName="book" schema="book_store" modelType="flat">
      <generatedKey column="id" sqlStatement="mysql" identity="true"/>
    </table>
  </context>
</generatorConfiguration>
```
根据该配置文件，yobatis会生成如下几个文件:
1. 与表book对应的base class, 该class每次都会被yobatis覆写。
```
package org.nalby.yobatis.book.model.base;

/*
 * This class corresponds to the table 'book', and is generated by MyBatis Generator.
 * Do NOT modify as it will be overwrote every time MyBatis Generator runs, put your code into
 * Book instead.
 */
public abstract class BaseBook {
    protected Long id;

    protected String name;

    protected Long author;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Long getAuthor() {
        return author;
    }

    public void setAuthor(Long author) {
        this.author = author;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(getClass().getSimpleName());
        sb.append("[");
        sb.append("id=").append(id);
        sb.append(", name=").append(name);
        sb.append(", author=").append(author);
        sb.append("]");
        return sb.toString();
    }

    /**
     * Copy properties of this object to {@code dest} object.
     * @param dest the object to copy properties to.
     * @return the dest object.
     */
    public BaseBook copy(BaseBook dest) {
        if (dest == null) {
            throw new NullPointerException("dest must not be null.");
        }
        dest.id = this.id;
        dest.name = this.name;
        dest.author = this.author;
        return dest;
    }
}
```
2. 与表book对应的class, 该class用于填充逻辑方法; yobatis不会覆盖该文件。
```
package org.nalby.yobatis.book.model;

import org.nalby.yobatis.book.model.base.BaseBook;
public class Book extends BaseBook {
}
```
3. 通用方法interface
```
package org.nalby.yobatis.book.mapper;

import java.util.List;
import org.nalby.yobatis.book.model.criteria.BaseCriteria;

/*
 * Do NOT modify, it will be overwrote every time yobatis runs.
 */
public interface BaseDao<T extends B, B, PK> {
    /**
     * Insert all fields of the record into table.
     * @param record the record to insert.
     * @return 1 if inserted successfully.
     * @throws IllegalArgumentException if record is null.
     */
    int insertAll(B record);

    /**
     * Insert all fields of the record into table.
     * @param record the record to insert.
     * @return 1 if inserted successfully, 0 if the insertion can not be done.
     * @throws IllegalArgumentException if record is null.
     */
    int insertAllIgnore(B record);

    /**
     * Insert non-null fields into the table. If the table has an auto_increment pk,
     * the primary key field will hold the generated key after insertion.
     * @param record the record to insert.
     * @return 1 if inserted successfully.
     * @throws IllegalArgumentException if record is null.
     */
    int insert(B record);

    /**
     * Select a record by primary key.
     * @param pk the primary key.
     * @return the record if found, null else.
     * @throws IllegalArgumentException if pk is null.
     */
    T selectOne(PK pk);

    /**
     * Select a record by criteria, a MybatisSystemException will be thrown if
     * more than one records meet the criteria.
     * @param criteria the criteria.
     * @return the record if one single record is selected, null if none selected.
     * @throws IllegalArgumentException if criteria is null or empty.
     * @throws MybatisSystemException if more than one records are yielded by the criteria.
     */
    T selectOne(BaseCriteria criteria);

    /**
     * Select records by criteria.
     * @param criteria the criteria.
     * @return a list of selected records, or an empty list if none meets the criteria.
     * @throws IllegalArgumentException if criteria is null or empty.
     */
    List<T> selectList(BaseCriteria criteria);

    /**
     * Count row number of the whole table.
     * @return the row number.
     */
    long countAll();

    /**
     * Count row number by criteria.
     * @param criteria the criteria to query rows.
     * @return the number of rows that meet the criteria.
     */
    long count(BaseCriteria criteria);

    /**
     * Update the record by primary key, null fields are ignored.
     * @param record the record that holds new values and the primary key.
     * @return 1 if updated successfully, 0 if no such a record.
     * @throws IllegalArgumentException if record is null.
     */
    int update(B record);

    /**
     * Update the record by primary key, all fields including null ones will be updated.
     * @param record the record that holds new values and the primary key.
     * @return 1 if updated successfully, 0 if no such a record.
     * @throws IllegalArgumentException if record is null.
     */
    int updateAll(B record);

    /**
     * Update non-null fields of the {@code record} to corresponding columns of the table.
     * @param record the new values.
     * @param criteria to query rows to update.
     * @return the number of affected rows.
     */
    int update(B record, BaseCriteria criteria);

    /**
     * Update all fields of the {@code record} to corresponding columns of the table.
     * @param record the new values.
     * @param criteria to query rows to update.
     * @return the number of affected rows.
     */
    int updateAll(B record, BaseCriteria criteria);

    /**
     * Delete the record by primary key.
     * @param pk the primary key.
     * @return 1 if deleted successfully, 0 if no such a record.
     * @throws IllegalArgumentException if pk is null.
     */
    int delete(PK pk);

    /**
     * Delete records by criteria.
     * @param criteria the criteria.
     * @return the number of deleted records.
     * @throws IllegalArgumentException if criteria is null or empty.
     */
    int delete(BaseCriteria criteria);
}
```
4. 通用方法的实现。
```
package org.nalby.yobatis.book.mapper.impl;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Resource;
import org.mybatis.spring.SqlSessionTemplate;
import org.nalby.yobatis.book.mapper.BaseDao;
import org.nalby.yobatis.book.model.criteria.BaseCriteria;

/*
 * Do NOT modify, it will be overwrote every time yobatis runs.
 */
public abstract class BaseDaoImpl<T extends B, B, PK> implements BaseDao<T, B, PK> {
    private static final String SELECT_BY_PK = "selectByPk";

    private static final String SELECT_BY_CRITERIA = "selectByCriteria";

    private static final String COUNT = "count";

    private static final String INSERT_ALL = "insertAll";

    private static final String INSERT_ALL_IGNORE = "insertAllIgnore";

    private static final String INSERT = "insert";

    private static final String DELETE_BY_PK = "deleteByPk";

    private static final String DELETE_BY_CRITERIA = "deleteByCriteria";

    private static final String UPDATE = "update";

    private static final String UPDATE_ALL = "updateAll";

    private static final String UPDATE_BY_CRITERIA = "updateByCriteria";

    private static final String UPDATE_ALL_BY_CRITERIA = "updateAllByCriteria";

    @Resource
    protected SqlSessionTemplate sqlSessionTemplate;

    protected abstract String namespace();

    protected final T doSelectOne(String statement, Object parameter) {
        return sqlSessionTemplate.selectOne(namespace() + statement, parameter);
    }

    protected final List<T> doSelectList(String statement, Object parameter) {
        return sqlSessionTemplate.selectList(namespace() + statement, parameter);
    }

    protected final int doUpdate(String statement, Object parameter) {
        return sqlSessionTemplate.update(namespace() + statement, parameter);
    }

    protected final int doInsert(String statement, Object parameter) {
        return sqlSessionTemplate.insert(namespace() + statement, parameter);
    }

    protected final int doDelete(String statement, Object parameter) {
        return sqlSessionTemplate.delete(namespace() + statement, parameter);
    }

    protected final void notNull(Object object, String errMsg) {
        if (object == null) {
            throw new IllegalArgumentException(errMsg);
        }
    }

    protected void validateCriteria(BaseCriteria criteria) {
        notNull(criteria, "criteria must not be null.");
        if (criteria.getOredCriteria().isEmpty()) {
            throw new IllegalArgumentException("criteria must not be empty.");
        }
    }

    protected Map<String, Object> makeParam(B record, BaseCriteria criteria) {
        notNull(record, "record must not be null.");
        validateCriteria(criteria);
        Map<String, Object> param = new HashMap<>();
        param.put("record", record);
        param.put("example", criteria);
        return param;
    }

    @Override
    public final int insertAll(B record) {
        notNull(record, "record must not be null.");
        return doInsert(INSERT_ALL, record);
    }

    @Override
    public final int insertAllIgnore(B record) {
        notNull(record, "record must not be null.");
        return doInsert(INSERT_ALL_IGNORE, record);
    }

    @Override
    public final int insert(B record) {
        notNull(record, "record must not be null.");
        return doInsert(INSERT, record);
    }

    @Override
    public final T selectOne(PK pk) {
        notNull(pk, "Primary key must not be null.");
        return doSelectOne(SELECT_BY_PK, pk);
    }

    @Override
    public final T selectOne(BaseCriteria criteria) {
        validateCriteria(criteria);
        return doSelectOne(SELECT_BY_CRITERIA, criteria);
    }

    @Override
    public final List<T> selectList(BaseCriteria criteria) {
        validateCriteria(criteria);
        return doSelectList(SELECT_BY_CRITERIA, criteria);
    }

    @Override
    public final long countAll() {
        return sqlSessionTemplate.selectOne(namespace() + COUNT, null);
    }

    @Override
    public final long count(BaseCriteria criteria) {
        validateCriteria(criteria);
        return sqlSessionTemplate.selectOne(this.namespace() + COUNT, criteria);
    }

    @Override
    public final int update(B record) {
        notNull(record, "record must not be null.");
        return doUpdate(UPDATE, record);
    }

    @Override
    public final int updateAll(B record) {
        notNull(record, "record must not be null.");
        return doUpdate(UPDATE_ALL, record);
    }

    @Override
    public final int update(B record, BaseCriteria criteria) {
        notNull(record, "record must not be null.");
        validateCriteria(criteria);
        return doUpdate(UPDATE_BY_CRITERIA, makeParam(record, criteria));
    }

    @Override
    public final int updateAll(B record, BaseCriteria criteria) {
        notNull(record, "record must not be null.");
        validateCriteria(criteria);
        return doUpdate(UPDATE_ALL_BY_CRITERIA, makeParam(record, criteria));
    }

    @Override
    public final int delete(PK pk) {
        notNull(pk, "pk must not be null.");
        return doDelete(DELETE_BY_PK, pk);
    }

    @Override
    public final int delete(BaseCriteria criteria) {
        validateCriteria(criteria);
        return doDelete(DELETE_BY_CRITERIA, criteria);
    }
}
```
5. BookDao 和 BookDaoImpl, yobaits不会覆写这2个文件，可以添加定制方法。
```
package org.nalby.yobatis.book.mapper;

import org.nalby.yobatis.book.model.Book;
import org.nalby.yobatis.book.model.base.BaseBook;

/*
 * It is safe to modify this file.
 */
public interface BookDao extends BaseDao<Book, BaseBook, Long> {
}
```
```
package org.nalby.yobatis.book.mapper.impl;

import org.nalby.yobatis.book.mapper.BookDao;
import org.nalby.yobatis.book.model.Book;
import org.nalby.yobatis.book.model.base.BaseBook;
import org.springframework.stereotype.Repository;

/*
 * It is safe to modify this file.
 */
@Repository("bookDao")
public final class BookDaoImpl extends BaseDaoImpl<Book, BaseBook, Long> implements BookDao {

    @Override
    protected String namespace() {
        return "org.nalby.yobatis.book.mapper.impl.BookDaoImpl.";
    }
}
```
6. 用于构造book查询条件的class, yobatis 每次运行都会覆盖该文件。
```
package org.nalby.yobatis.book.model.criteria;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/*
 * Do NOT modify, it will be overwrote every time yobatis runs.
 */
/**
 * A BookCriteria provides methods to construct 'where', 'limit', 'offset', 'for update'
 * clauses. Although building 'limit', 'offset', 'for update' and simple 'where' clauses is pretty
 * intuitive, a complex 'where' clause requires a little bit more attention.
 * <p>A complex 'where' consists of multiple expressions that are ORed together, such as <br>
 * {@code (id = 1 and field = 2) or (filed <= 3) or ( ... ) ...}
 * <p>Suppose we had a Book model which has author and name fields,
 * here is an example that utilizes BookCriteria to build a where clause of<br>
 * {@code (author = "Some author" and name = "Some book") or (name not in ("hated ones", "boring ones"))}
 * <pre>
 * BookCriteria.authorEqualTo("Some author")
 * .andNameEqualTo("Some book")
 * .or()
 * .andNameNotIn(Arrays.asList("hated ones", "boring ones"));
 * </pre>
 */
public class BookCriteria extends BaseCriteria {
    private static final Map<String, String> PROPERTY_TO_COLUMN;

    static {
        PROPERTY_TO_COLUMN = new HashMap<String, String>();
        PROPERTY_TO_COLUMN.put("id", "id");
        PROPERTY_TO_COLUMN.put("name", "name");
        PROPERTY_TO_COLUMN.put("author", "author");
    }

    protected void orderBy(String  order, String  ... fields) {
        if ( fields == null || fields.length == 0) {
            throw new IllegalArgumentException("Empty fields passed.");
        }
        StringBuilder stringBuilder = new StringBuilder();
        if (orderByClause != null) {
            stringBuilder.append(orderByClause);
            stringBuilder.append(',');
        }
        for (String field : fields) {
            if (!PROPERTY_TO_COLUMN.containsKey(field)) {
                throw new IllegalArgumentException("Unrecognizable field:" + field);
            }
            stringBuilder.append(PROPERTY_TO_COLUMN.get(field));
            stringBuilder.append(" ");
            stringBuilder.append(order);
            stringBuilder.append(',');
        }
        stringBuilder.deleteCharAt(stringBuilder.length() - 1);
        orderByClause = stringBuilder.toString();
    }
    .
    .
    .
}
```
7. xml mapper, yobatis会保留手工添加的element；带有注释 WARNING - @mbg.generated 的 elements每次都会被覆盖。
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.nalby.yobatis.book.mapper.impl.BookDaoImpl">
  <resultMap id="BASE_RESULT_MAP" type="org.nalby.yobatis.book.model.Book">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    <id column="id" jdbcType="BIGINT" property="id"/>
    <result column="name" jdbcType="CHAR" property="name"/>
    <result column="author" jdbcType="BIGINT" property="author"/>
  </resultMap>
  <sql id="WHERE_CLAUSE">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    <where>
      <foreach collection="oredCriteria" item="criteria" separator="or">
        <if test="criteria.valid">
          <trim prefix="(" prefixOverrides="and" suffix=")">
            <foreach collection="criteria.criteria" item="criterion">
              <choose>
                <when test="criterion.noValue">
                  and ${criterion.condition}
                </when>
                <when test="criterion.singleValue">
                  and ${criterion.condition} #{criterion.value}
                </when>
                <when test="criterion.betweenValue">
                  and ${criterion.condition} #{criterion.value} and #{criterion.secondValue}
                </when>
                <when test="criterion.listValue">
                  and ${criterion.condition}
                  <foreach close=")" collection="criterion.value" item="listItem" open="(" separator=",">
                    #{listItem}
                  </foreach>
                </when>
              </choose>
            </foreach>
          </trim>
        </if>
      </foreach>
    </where>
  </sql>
  <sql id="WHERE_CLAUSE_FOR_UPDATE">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    <where>
      <foreach collection="example.oredCriteria" item="criteria" separator="or">
        <if test="criteria.valid">
          <trim prefix="(" prefixOverrides="and" suffix=")">
            <foreach collection="criteria.criteria" item="criterion">
              <choose>
                <when test="criterion.noValue">
                  and ${criterion.condition}
                </when>
                <when test="criterion.singleValue">
                  and ${criterion.condition} #{criterion.value}
                </when>
                <when test="criterion.betweenValue">
                  and ${criterion.condition} #{criterion.value} and #{criterion.secondValue}
                </when>
                <when test="criterion.listValue">
                  and ${criterion.condition}
                  <foreach close=")" collection="criterion.value" item="listItem" open="(" separator=",">
                    #{listItem}
                  </foreach>
                </when>
              </choose>
            </foreach>
          </trim>
        </if>
      </foreach>
    </where>
  </sql>
  <sql id="BASE_COLUMN_LIST">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    id, name, author
  </sql>
  <select id="selectByCriteria" parameterType="org.nalby.yobatis.book.model.criteria.BookCriteria" resultMap="BASE_RESULT_MAP">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    select
    <if test="distinct">
      distinct
    </if>
    <include refid="BASE_COLUMN_LIST"/>
    from book
    <if test="_parameter != null">
      <include refid="WHERE_CLAUSE"/>
    </if>
    <if test="orderByClause != null">
      order by ${orderByClause}
    </if>
    <if test="limit != null">
      limit #{limit}
    </if>
    <if test="offset != null">
      offset #{offset}
    </if>
    <if test="forUpdate != null and forUpdate == true">
      for update
    </if>
  </select>
  <select id="selectByPk" parameterType="java.lang.Long" resultMap="BASE_RESULT_MAP">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    select 
    <include refid="BASE_COLUMN_LIST"/>
    from book
    where id = #{id,jdbcType=BIGINT}
  </select>
  <delete id="deleteByPk" parameterType="java.lang.Long">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    delete from book
    where id = #{id,jdbcType=BIGINT}
  </delete>
  <delete id="deleteByCriteria" parameterType="org.nalby.yobatis.book.model.criteria.BookCriteria">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    delete from book
    <if test="_parameter != null">
      <include refid="WHERE_CLAUSE"/>
    </if>
  </delete>
  <insert id="insertAll" parameterType="org.nalby.yobatis.book.model.base.BaseBook">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    insert into book (id, name, author)
    values (#{id,jdbcType=BIGINT}, #{name,jdbcType=CHAR}, #{author,jdbcType=BIGINT})
  </insert>
  <insert id="insertAllIgnore" parameterType="org.nalby.yobatis.book.model.base.BaseBook">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    insert ignore into book (id, name, author)
    values (#{id,jdbcType=BIGINT}, #{name,jdbcType=CHAR}, #{author,jdbcType=BIGINT})
  </insert>
  <insert id="insert" parameterType="org.nalby.yobatis.book.model.base.BaseBook">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Long">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into book
    <trim prefix="(" suffix=")" suffixOverrides=",">
      <if test="name != null">
        name,
      </if>
      <if test="author != null">
        author,
      </if>
    </trim>
    <trim prefix="values (" suffix=")" suffixOverrides=",">
      <if test="name != null">
        #{name,jdbcType=CHAR},
      </if>
      <if test="author != null">
        #{author,jdbcType=BIGINT},
      </if>
    </trim>
  </insert>
  <select id="count" parameterType="org.nalby.yobatis.book.model.criteria.BookCriteria" resultType="java.lang.Long">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    select count(*) from book
    <if test="_parameter != null">
      <include refid="WHERE_CLAUSE"/>
    </if>
  </select>
  <update id="updateByCriteria" parameterType="map">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    update book
    <set>
      <if test="record.id != null">
        id = #{record.id,jdbcType=BIGINT},
      </if>
      <if test="record.name != null">
        name = #{record.name,jdbcType=CHAR},
      </if>
      <if test="record.author != null">
        author = #{record.author,jdbcType=BIGINT},
      </if>
    </set>
    <if test="_parameter != null">
      <include refid="WHERE_CLAUSE_FOR_UPDATE"/>
    </if>
  </update>
  <update id="updateAllByCriteria" parameterType="map">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    update book
    set id = #{record.id,jdbcType=BIGINT},
      name = #{record.name,jdbcType=CHAR},
      author = #{record.author,jdbcType=BIGINT}
    <if test="_parameter != null">
      <include refid="WHERE_CLAUSE_FOR_UPDATE"/>
    </if>
  </update>
  <update id="update" parameterType="org.nalby.yobatis.book.model.base.BaseBook">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    update book
    <set>
      <if test="name != null">
        name = #{name,jdbcType=CHAR},
      </if>
      <if test="author != null">
        author = #{author,jdbcType=BIGINT},
      </if>
    </set>
    where id = #{id,jdbcType=BIGINT}
  </update>
  <update id="updateAll" parameterType="org.nalby.yobatis.book.model.base.BaseBook">
    <!--
      WARNING - @mbg.generated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    update book
    set name = #{name,jdbcType=CHAR},
      author = #{author,jdbcType=BIGINT}
    where id = #{id,jdbcType=BIGINT}
  </update>
</mapper>
```
# API文档
[文档连接](https://linbaiye.github.io/yobatis/doc.html)


